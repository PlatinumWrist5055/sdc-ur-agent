#!/usr/node/bin/node --abort_on_uncaught_exception

var execFile = require('child_process').execFile;
var amqp = require('./amqp-plus');
var fs = require('fs');
var util = require('util');
var path = require('path');
var bunyan = require('bunyan');

var debug = false;
if (process.env['UR_DEBUG']) {
    debug = true;
}

var urlog = bunyan.createLogger({name: 'ur', level: 'debug'});
var joblog = bunyan.createLogger({name: 'job', level: 'debug'});

var creds = {
    host: process.env['AMQP_HOST'] || 'localhost',
    port: process.env['AMQP_PORT'] || 5672,
    login: process.env['AMQP_LOGIN'] || 'guest',
    password: process.env['AMQP_PASSWORD'] || 'guest',
    vhost: process.env['AMQP_VHOST'] || '/'
};

var MAX_BUFFER = 5 * 1024 * 1024;
var nodeUUID;
var exchange;
var queue;
var sysinfo;
var connecting;
var adminMac;
var heartbeatSeconds = 30;

var connection;

var reconnectAttempts = 0;
var maxReconnectAttempts = 3;
var broadcastSetupStateInterval;

connect();

function setupPingQueue() {
    var resource = 'ur';
    var queueName = resource + '.ping.' + nodeUUID;
    var pq = connection.queue(queueName);

    pq.addListener('open', function (messageCount, consumerCount) {
        pq.subscribe({ ack: true }, function (msg, headers, deliveryInfo) {
            urlog.info('Received ping message');
            var client_id = msg.client_id;
            var id = msg.id;

            var reply = {
                req_id: id,
                timestamp: new Date().toISOString()
            };
            var routingKey = resource + '.ack' + client_id + '.' + nodeUUID;


            urlog.info('Publishing ping reply to ' + routingKey);
            exchange.publish(routingKey, reply);

            pq.shift();
        });

        pq.bind(
            'amq.topic',
            resource + '.ping.' + nodeUUID);
    });
}

var setupStateFile = '/var/lib/setup.json';

function readSetupStateFile(callback) {
    fs.readFile(setupStateFile, function (error, data) {
        if (error) {
            urlog.error(
                'Error reading file %s: %s', setupStateFile, error.message);
            callback(error);
            return;
        }

        var setupState;

        try {
            setupState = JSON.parse(data.toString());
        }
        catch (e) {
            urlog.error(
                'could not parse %s: %s', setupStateFile, error.message);
            callback(error);
            return;
        }

        callback(null, setupState);
        return;
    });
}

function setupStateChecker() {
    clearInterval(broadcastSetupStateInterval);
    broadcastSetupStateInterval = null;

    check();

    function publish() {
        loadSysinfo(function (err, exitStatus, stdout, stderr) {
            if (err) {
                urlog.error('sysinfo error: ' + stderr.toString());
                dump(arguments);
                return;
            }
            sysinfo = JSON.parse(stdout);
            exchange.publish(
                pjoin('ur.sysinfo', nodeUUID, genId()), sysinfo);
        });
    }

    function check() {
        fs.exists(setupStateFile, function (exists) {
            if (!exists) {
                if (!broadcastSetupStateInterval) {
                    urlog.debug(
                        'Server isn\'t set up, initiating polling');
                    broadcastSetupStateInterval
                        = setInterval(function () {
                            check();
                        }, 60000);
                }
                publish();
                return;
            }

            readSetupStateFile(function (error, setupState) {
                if (setupState.complete === true) {
                    urlog.debug('Server is setup!');
                    clearInterval(broadcastSetupStateInterval);
                    broadcastSetupStateInterval = null;
                    publish();
                    return;
                }

                if (!broadcastSetupStateInterval) {
                    urlog.debug(
                        'Server isn\'t set up, initiating polling');
                    broadcastSetupStateInterval
                        = setInterval(function () {
                            check();
                        }, 60000);
                }
                publish();
            });
        });
    }
}

var heartbeatInterval;
function onReady() {
    connection.heartbeat();
    heartbeatInterval = setInterval(publishHeartbeat, heartbeatSeconds * 1000);
    function publishHeartbeat() {
        connection.heartbeat();
    }

    // Grab the sysinfo and publish a startup message indicating we've come
    // online and are ready to receive requests.
    loadSysinfo(function (error, exitStatus, stdout, stderr) {
        if (error) {
            urlog.error('sysinfo error: ' + stderr.toString());
            dump(arguments);
            return;
        }

        // output of sysinfo is a JSON object
        sysinfo = JSON.parse(stdout);

        // Use the UUID param to uniquely identify this machine on AMQP.
        nodeUUID = sysinfo['UUID'];
        if (!nodeUUID) {
            throw new Error('Could not find "UUID" in `sysinfo` output.');
        }

        // Open the exchange where we will publish outbound messages.
        exchange = connection.exchange('amq.topic', { type: 'topic' });
        setupStateChecker();

        adminMac = firstAdminMac();
        bindQueue();
    });
}

function connect() {
    creds.heartbeat = heartbeatSeconds;
    connection = new amqp.Connection(creds, { log: urlog });
    connection.on('ready', onReady);
    connection.on('end', function () {
        clearInterval(heartbeatInterval);
    });
    connection.reconnect();
}

function firstAdminMac() {
    var interfaces = sysinfo['Network Interfaces'];
    var mac;
    for (var iface in interfaces) {
        if (!interfaces.hasOwnProperty(iface)) continue;

        var nic = interfaces[iface]['NIC Names'];
        var isAdmin = nic.indexOf('admin') !== -1;
        if (isAdmin) {
            mac = interfaces[iface]['MAC Address'];
            return mac;
        }
    }

    throw new Error('No NICs with name "admin" detected.');
}


function bindQueue() {
    queue = connection.queue(
        'ur.request.'+nodeUUID+'.'+adminMac, { exclusive: true });

    queue.on('error', function (e) {
        var AMQP_RESOURCE_LOCKED = 405;

        if (e.code !== AMQP_RESOURCE_LOCKED) {
            urlog.error('AMQP Queue Error received: ' + e.message);
            return;
        }

        if (++reconnectAttempts > maxReconnectAttempts) {
            urlog.error('Could not acquire exclusive ur queue after '
            + reconnectAttempts + ' attempts.');
            process.exit(1);
        }

        urlog.error('Detected another client our the Ur queue (Attempt: '
            + [reconnectAttempts, maxReconnectAttempts].join('/') + ')');
            exchange.publish(pjoin('ur.execute', nodeUUID, genId()), {});

            setTimeout(function () {
                connection.end();
            }, 5000);
    });

    queue.on('open', function () {
        reconnectAttempts = 0;
        setupPingQueue();
        queue.bind(
            'amq.topic', 'ur.execute.' + nodeUUID + '-' + adminMac + '.*');
        queue.bind('amq.topic', 'ur.execute.' + nodeUUID + '.*');
        queue.bind('amq.topic', 'ur.broadcast.*.*');
        queue.subscribe({ ack: true }, onExecute);

        var urStartupFilePath = '/tmp/.ur-startup';
        fs.exists(urStartupFilePath, function (exists) {
            if (!exists) {
                fs.writeFile(urStartupFilePath, '', function (error) {
                    if (error)
                        throw error;

                    // Open the exchange for publishing outbound messages.
                    var routingKey = 'ur.startup.' + nodeUUID;
                    urlog.info('Sending startup message to routing key '
                        + routingKey);
                    dump(sysinfo);
                    exchange.publish(routingKey, sysinfo);
                });
            }
        });
    });
}

function onExecute(m, headers, deliveryInfo) {
    dump(m);
    queue.shift();

    // Save the request id so we can reference it in the reply's routing key.
    var key = deliveryInfo.routingKey.split('.', 4);
    var reqID = key[3];
    urlog.info(
        { req_id: reqID },
        'Received a message to routing key: ' + deliveryInfo.routingKey);

    if (key[1] == 'broadcast') {
        switch (key[2]) {
            case 'sysinfo':
                loadSysinfo(function (error, exitStatus, stdout, stderr) {
                    if (error) {
                        urlog.error(
                            { req_id: reqID},
                            'broadcast sysinfo error: ' + stderr.toString());
                        return;
                    }
                    publishBroadcastReply(reqID, JSON.parse(stdout));
                });
                break;
            default:
                urlog.info(
                    { req_id: reqID}, 'unknown broadcast key "%s"',
                    key[2]);
                break;
        }

        return;
    }

    switch (m.type) {
        case 'file':
            executeFile(
                m.file,
                m.env,
                m.args,
                replyFn);

            break;

        case 'script':
            executeScript(
                m.script,
                m.env,
                m.args,
                replyFn);

            break;

        default:
            urlog.warn('Unknown message type: %s', m.type);
            break;
    }

    function replyFn(error, stdout, stderr) {
        // An exit status of 113 from the executable indicates that we want the
        // machine to reboot after we reply.
        var exitStatus = error.code;
        var publishExitStatus = error.code === 113 || error.code === undefined ? 0 : error.code;
        publishExecuteReply(
            reqID,
            { code: publishExitStatus },
            stdout,
            stderr,
            function () {
                // Reboot if the exit status code is 113. 113 or 1/13 is the
                // 30th prime number and also an "Einstein Prime".
                if (exitStatus !== 113) {
                    return;
                }

                // Allow some time for node gnomes to carry our reply AMQP
                // packets away before we reboot the machine.
                setTimeout(function () {
                    connection.end();
                    if (debug) {
                        fakeReboot();
                    } else {
                        reboot();
                    }
                }, 1000);
            });
    }
}

function reboot() {
    execFile(
        '/usr/sbin/shutdown',
        ['-y', '-g', '0', '-i', '6'],
        function (error, stdout, stderr) {
            if (error) {
                throw new Error(stderr.toString());
            }
            setTimeout(function () {
                forceReboot();
            }, 5*60*1000);
        });
}

function forceReboot() {
    execFile(
        '/usr/sbin/reboot',
        [],
        function () {
                // Wait for reboot
        });
}

function fakeReboot() {
    urlog.info('I am so rebooting right now.');
    process.exit(0);
}

// Execute a file and then call callback with captured output and exit status
// code.
function executeFile(filename, env, args, callback) {
    var new_env;

    urlog.info('Executing file: ' + filename);

    new_env = env;
    if (!new_env) {
        new_env = {};
    }

    if (process.env['MOCKCN_SERVER_UUID']) {
        new_env['MOCKCN_SERVER_UUID'] = process.env['MOCKCN_SERVER_UUID'];
    }

    execFile(
        filename,
        args || [],
        { env: new_env, maxBuffer: MAX_BUFFER },
        function (error, stdout, stderr) {
            if (error) {
                callback(error, stdout.toString(), stderr.toString());
                return;
            }
            stdout = stdout.toString();
            stderr = stderr.toString();

            urlog.info('Exit status for %s was.',
                filename, error ? error.code : 0);
            urlog.info('STDOUT:');
            urlog.info(stdout);
            urlog.info('STDERR:');
            urlog.info(stderr);

            callback(0, stdout, stderr);
        });
}

// Execute a script string.
function executeScript(script, env, args, callback) {
    urlog.info('Executing script: ' + script);
    var filename = tmpFilename();
    urlog.info('Writing file ' + filename);

    // Write file, 'chmod 700' it, run it, delete file.
    fs.writeFile(filename, script, function () {
        fs.chmod(filename, parseInt('0700', 8), function () {
            executeFile(filename, env, args, function (error, stdout, stderr) {
                urlog.info('Execute complete (%s)', filename);
                var execArgs = Array.prototype.slice.apply(arguments);
                fs.unlink(filename, function (ulerror) {
                    if (ulerror) {
                        urlog.info('Error unlinking file (%s)', filename);
                    }

                    callback.apply(undefined, execArgs);
                });
            });
        });
    });
}

// Publish an 'ur.execute-reply'-type message to AMQP.
function publishExecuteReply(reqID, error, stdout, stderr, callback) {
    var exitStatus = 0;
    urlog.info({ err: error }, "publishExecuteReply return");

    if (error) {
        if (error.code === 0 || error.code) {
            exitStatus = error.code;
        } else {
            exitStatus = 1;
            stderr = error.message;
        }
    }

    var reply = {
        exit_status: exitStatus,
        stdout:      stdout,
        stderr:      stderr
    };
    var routingKey = 'ur.execute-reply.' + nodeUUID + '.' + reqID;
    urlog.info('Publishing execute-reply to request ' + reqID + ':');
    dump(reply);

    exchange.publish(routingKey, reply);
    callback();
}

function publishBroadcastReply(reqID, reply) {
    var routingKey = 'ur.execute-reply.' + nodeUUID + '.' + reqID;
    urlog.info('Publishing execute-reply to broadcast request ' + reqID + ':');
    dump(reply);

    exchange.publish(
        routingKey,
        reply);
}

// Quick and dirty generation of tmp filenames.
function tmpFilename() {
    return '/tmp/ur-' + genId();
}

// Run the sysinfo script and return the captured stdout, stderr, and exit
// status code.
function loadSysinfo(callback) {
    var paramsExecutable = debug ? './sysinfo-fake.sh' : '/usr/bin/sysinfo';

    execFile(
        paramsExecutable,
        [],
        function (exitStatus, stdout, stderr) {
            if (exitStatus) {
                callback(new Error(stderr), exitStatus, stdout, stderr);
                return;
            }

            callback(
                undefined,
                exitStatus,
                stdout.toString().trim(),
                stderr.toString().trim());
        });
}

// Generate a hex representation of a random four byte string.
function genId() {
    return Math.floor(Math.random() * 0xffffffff).toString(16);
}

function dump(obj, depth) {
    urlog.info(util.inspect(obj, true, depth ? depth : 20));
}

function pjoin() {
    return Array.prototype.join.call(arguments, '.');
}
